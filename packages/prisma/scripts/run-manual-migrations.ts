/**
 * Run Manual SQL Migrations
 * 
 * This script runs manual SQL migration files using pg Client directly (not Prisma).
 * These are migrations that can't be generated by Prisma (triggers, functions, partial indexes, etc.)
 * 
 * Usage:
 *   tsx packages/prisma/scripts/run-manual-migrations.ts                    # Run all migrations
 *   tsx packages/prisma/scripts/run-manual-migrations.ts 004_partial_index  # Run specific migration
 *   tsx packages/prisma/scripts/run-manual-migrations.ts --force             # Force re-run (ignore errors)
 */

import { readFileSync, existsSync } from 'fs';
import { join } from 'path';
import { fileURLToPath } from 'url';
import { dirname } from 'path';
import { Client } from 'pg';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// Get database connection from DATABASE_URL
const getDbClient = async () => {
  const dbUrl = process.env.DATABASE_URL;
  if (!dbUrl) {
    throw new Error('DATABASE_URL environment variable is not set');
  }
  const client = new Client({ connectionString: dbUrl });
  await client.connect();
  return client;
};

// List of manual migration files in execution order
const MANUAL_MIGRATIONS = [
  '000_production_triggers.sql',
  '001_performance_indexes.sql',
  '002_materialized_view_daily_stats.sql',
  '003_router_daily_usage_triggers.sql',
  '004_partial_index_and_stoptime.sql',
];

async function runSingleMigration(migrationFile: string, force: boolean = false) {
  const migrationsDir = join(__dirname, '..', 'manual-migrations');
  const filePath = join(migrationsDir, migrationFile);
  
  if (!existsSync(filePath)) {
    throw new Error(`Migration file not found: ${filePath}`);
  }
  
  console.log(`ğŸ“„ Executing: ${migrationFile}`);
  const sql = readFileSync(filePath, 'utf-8');
  
  const client = await getDbClient();
  try {
    await client.query(sql);
    console.log(`âœ… Completed: ${migrationFile}\n`);
    return true;
  } catch (error: any) {
    // Check if it's a "already exists" error (idempotent)
    const isIdempotentError = 
      error.message?.includes('already exists') || 
      error.message?.includes('duplicate') ||
      error.code === '42P07' || // PostgreSQL: duplicate_table
      error.code === '42710';   // PostgreSQL: duplicate_object
    
    if (isIdempotentError) {
      console.log(`â­ï¸  Skipped (already applied): ${migrationFile}\n`);
      return true;
    } else {
      console.error(`âŒ Error executing ${migrationFile}:`, error.message);
      if (force) {
        console.log(`âš ï¸  Force mode: Continuing despite error...\n`);
        return false;
      }
      throw error;
    }
  } finally {
    await client.end();
  }
}

async function runManualMigrations(specificMigration?: string, force: boolean = false) {
  const migrationsDir = join(__dirname, '..', 'manual-migrations');
  
  console.log('ğŸ”§ Running manual SQL migrations...\n');
  console.log('ğŸ“Œ Using pg Client directly (bypassing Prisma for multi-statement SQL)\n');

  // If specific migration requested, find and run it
  if (specificMigration) {
    // Allow partial matches (e.g., "004" matches "004_partial_index_and_stoptime.sql")
    const matchingMigration = MANUAL_MIGRATIONS.find(m => 
      m.includes(specificMigration) || specificMigration.includes(m.replace('.sql', ''))
    );
    
    if (!matchingMigration) {
      console.error(`âŒ Migration not found: ${specificMigration}`);
      console.log('Available migrations:');
      MANUAL_MIGRATIONS.forEach(m => console.log(`  - ${m}`));
      process.exit(1);
    }
    
    await runSingleMigration(matchingMigration, force);
    console.log('âœ¨ Migration completed!');
    return;
  }

  // Run all migrations in order
  for (const migrationFile of MANUAL_MIGRATIONS) {
    try {
      await runSingleMigration(migrationFile, force);
    } catch (error: any) {
      if (force) {
        console.error(`âš ï¸  Migration ${migrationFile} failed, but continuing (force mode)...\n`);
        continue;
      }
      throw error;
    }
  }

  console.log('âœ¨ All manual migrations completed successfully!');
}

async function main() {
  const args = process.argv.slice(2);
  const force = args.includes('--force') || args.includes('-f');
  const specificMigration = args.find(arg => !arg.startsWith('--') && !arg.startsWith('-'));

  try {
    await runManualMigrations(specificMigration, force);
  } catch (error: any) {
    console.error('âŒ Migration failed:', error.message);
    if (!force) {
      console.error('\nğŸ’¡ Tip: Use --force flag to continue despite errors');
      console.error('ğŸ’¡ Tip: Run specific migration: tsx run-manual-migrations.ts 004_partial_index');
    }
    process.exit(1);
  }
}

main();

