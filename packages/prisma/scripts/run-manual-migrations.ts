/**
 * Run Manual SQL Migrations
 * 
 * This script runs manual SQL migration files using pg Client directly (not Prisma).
 * These are migrations that can't be generated by Prisma (triggers, functions, partial indexes, etc.)
 * 
 * Usage:
 *   tsx packages/prisma/scripts/run-manual-migrations.ts                    # Run all migrations
 *   tsx packages/prisma/scripts/run-manual-migrations.ts 004_partial_index  # Run specific migration
 *   tsx packages/prisma/scripts/run-manual-migrations.ts --force             # Force re-run (ignore errors)
 */

import { readFileSync, existsSync } from 'fs';
import { join } from 'path';
import { fileURLToPath } from 'url';
import { dirname } from 'path';
import { Client } from 'pg';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// Get database connection from DATABASE_URL
const getDbClient = async () => {
  const dbUrl = process.env.DATABASE_URL;
  if (!dbUrl) {
    throw new Error('DATABASE_URL environment variable is not set');
  }
  const client = new Client({ connectionString: dbUrl });
  await client.connect();
  return client;
};

// List of manual migration files in execution order
const MANUAL_MIGRATIONS = [
  '000_production_triggers.sql',
  '001_performance_indexes.sql',
  '002_materialized_view_daily_stats.sql',
  '003_router_daily_usage_triggers.sql',
  '004_partial_index_and_stoptime.sql',
  '005_realtime_quota.sql',
  '006_user_quota_counters.sql',
  '007_plan_expiry_trigger.sql', // Plan expiry with NOTIFY/LISTEN (event-driven)
  '009_pg_notify_disconnect_queue.sql', // PG_NOTIFY for real-time quota enforcement
  '010_radacct_callingstationid_index.sql', // Index for MAC address lookups
  '011_session_counter_redis_trigger.sql', // Redis session counter trigger
];

async function runSingleMigration(migrationFile: string, force: boolean = false) {
  const migrationsDir = join(__dirname, '..', 'manual-migrations');
  const filePath = join(migrationsDir, migrationFile);

  if (!existsSync(filePath)) {
    throw new Error(`Migration file not found: ${filePath}`);
  }

  console.log(`ğŸ“„ Executing: ${migrationFile}`);
  const sql = readFileSync(filePath, 'utf-8');

  // Check if this migration explicitly requests single transaction mode
  const forceSingleTransaction = sql.includes('-- RUN_IN_SINGLE_TRANSACTION');

  // Check if this migration contains CONCURRENTLY statements
  // These cannot run inside a transaction block, so we need to run each statement separately
  const hasConcurrently = !forceSingleTransaction && sql.toUpperCase().includes('CONCURRENTLY');

  const client = await getDbClient();
  try {
    if (hasConcurrently) {
      console.log(`   âš¡ Detected CONCURRENTLY - running statements outside transaction`);
      // Split SQL into individual statements and run each separately
      // This handles CREATE INDEX CONCURRENTLY which can't be in a transaction
      const statements = sql
        .split(';')
        .map(s => s.trim())
        .filter(s => s.length > 0 && !s.startsWith('--'));

      for (const statement of statements) {
        try {
          await client.query(statement);
        } catch (stmtError: any) {
          // Check if it's an idempotent error for this statement
          const isIdempotentError =
            stmtError.message?.includes('already exists') ||
            stmtError.message?.includes('duplicate') ||
            stmtError.code === '42P07' || // PostgreSQL: duplicate_table
            stmtError.code === '42710';   // PostgreSQL: duplicate_object

          if (isIdempotentError) {
            console.log(`   â­ï¸  Statement skipped (already applied)`);
          } else {
            throw stmtError;
          }
        }
      }
    } else {
      await client.query(sql);
    }
    console.log(`âœ… Completed: ${migrationFile}\n`);
    return true;
  } catch (error: any) {
    // Check if it's a "already exists" error (idempotent)
    const isIdempotentError =
      error.message?.includes('already exists') ||
      error.message?.includes('duplicate') ||
      error.code === '42P07' || // PostgreSQL: duplicate_table
      error.code === '42710';   // PostgreSQL: duplicate_object

    if (isIdempotentError) {
      console.log(`â­ï¸  Skipped (already applied): ${migrationFile}\n`);
      return true;
    } else {
      console.error(`âŒ Error executing ${migrationFile}:`, error.message);
      if (force) {
        console.log(`âš ï¸  Force mode: Continuing despite error...\n`);
        return false;
      }
      throw error;
    }
  } finally {
    await client.end();
  }
}

async function runManualMigrations(specificMigration?: string, force: boolean = false) {
  const migrationsDir = join(__dirname, '..', 'manual-migrations');

  console.log('ğŸ”§ Running manual SQL migrations...\n');
  console.log('ğŸ“Œ Using pg Client directly (bypassing Prisma for multi-statement SQL)\n');

  // If specific migration requested, find and run it
  if (specificMigration) {
    // Allow partial matches (e.g., "004" matches "004_partial_index_and_stoptime.sql")
    const matchingMigration = MANUAL_MIGRATIONS.find(m =>
      m.includes(specificMigration) || specificMigration.includes(m.replace('.sql', ''))
    );

    if (!matchingMigration) {
      console.error(`âŒ Migration not found: ${specificMigration}`);
      console.log('Available migrations:');
      MANUAL_MIGRATIONS.forEach(m => console.log(`  - ${m}`));
      process.exit(1);
    }

    await runSingleMigration(matchingMigration, force);
    console.log('âœ¨ Migration completed!');
    return;
  }

  // Run all migrations in order
  for (const migrationFile of MANUAL_MIGRATIONS) {
    try {
      await runSingleMigration(migrationFile, force);
    } catch (error: any) {
      if (force) {
        console.error(`âš ï¸  Migration ${migrationFile} failed, but continuing (force mode)...\n`);
        continue;
      }
      throw error;
    }
  }

  console.log('âœ¨ All manual migrations completed successfully!');
}

async function main() {
  const args = process.argv.slice(2);
  const force = args.includes('--force') || args.includes('-f');
  const specificMigration = args.find(arg => !arg.startsWith('--') && !arg.startsWith('-'));

  try {
    await runManualMigrations(specificMigration, force);
  } catch (error: any) {
    console.error('âŒ Migration failed:', error.message);
    if (!force) {
      console.error('\nğŸ’¡ Tip: Use --force flag to continue despite errors');
      console.error('ğŸ’¡ Tip: Run specific migration: tsx run-manual-migrations.ts 004_partial_index');
    }
    process.exit(1);
  }
}

main();

