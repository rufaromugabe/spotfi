generator client {
  provider = "prisma-client-js"
  previewFeatures = ["fullTextSearch"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
  // Connection pool optimization for production
  // Configure via DATABASE_URL: ?connection_limit=20&pool_timeout=20
}

model User {
  id        String   @id @default(cuid())
  email     String   @unique
  password  String
  role      Role     @default(HOST)
  routers   Router[]
  invoices  Invoice[]
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("users")
}

model Router {
  id           String    @id @default(cuid())
  name         String
  hostId       String
  host         User      @relation(fields: [hostId], references: [id], onDelete: Cascade)
  token        String    @unique
  uamSecret    String?   @unique @map("radiusSecret") // Unique UAM secret for portal/CHAP
  status       RouterStatus @default(OFFLINE)
  lastSeen     DateTime?
  totalUsage   Decimal   @default(0) @db.Decimal(12, 2)
  nasipaddress String?
  macAddress   String?   // Router MAC address for robust tracking (doesn't change like IP)
  location     String?
  invoices     Invoice[]
  sessions     RadAcct[]
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  @@index([hostId])
  @@index([macAddress])
  @@map("routers")
}

model Invoice {
  id          String   @id @default(cuid())
  hostId      String
  host        User     @relation(fields: [hostId], references: [id], onDelete: Cascade)
  routerId    String
  router      Router   @relation(fields: [routerId], references: [id], onDelete: Cascade)
  amount      Decimal   @db.Decimal(10, 2)
  period      DateTime
  usage       Decimal   @db.Decimal(12, 2)
  status      InvoiceStatus @default(PENDING)
  paidAt      DateTime?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([hostId])
  @@index([routerId])
  @@index([period])
  @@index([hostId, period])
  @@map("invoices")
}

// FreeRADIUS accounting table - lowercase for PostgreSQL compatibility
model RadAcct {
  radAcctId           BigInt    @id @default(autoincrement()) @map("radacctid")
  acctSessionId       String    @map("acctsessionid")
  acctUniqueId        String    @unique @map("acctuniqueid")
  userName            String?   @map("username")
  realm               String?   @map("realm")
  nasIpAddress        String    @map("nasipaddress")
  nasPortId           String?   @map("nasportid")
  nasPortType         String?   @map("nasporttype")
  acctStartTime       DateTime? @map("acctstarttime")
  acctUpdateTime      DateTime? @map("acctupdatetime")
  acctStopTime        DateTime? @map("acctstoptime")
  acctInterval        BigInt?   @map("acctinterval")
  acctSessionTime     BigInt?   @map("acctsessiontime")
  acctAuthentic       String?   @map("acctauthentic")
  connectInfoStart    String?   @map("connectinfo_start")
  connectInfoStop     String?   @map("connectinfo_stop")
  acctInputOctets     BigInt?   @map("acctinputoctets")
  acctOutputOctets    BigInt?   @map("acctoutputoctets")
  calledStationId     String?   @map("calledstationid")
  callingStationId    String?   @map("callingstationid")
  acctTerminateCause  String?   @map("acctterminatecause")
  serviceType         String?   @map("servicetype")
  framedProtocol      String?   @map("framedprotocol")
  framedIpAddress     String?   @map("framedipaddress")
  framedIpv6Address   String?   @map("framedipv6address")
  framedIpv6Prefix    String?   @map("framedipv6prefix")
  framedInterfaceId   String?   @map("framedinterfaceid")
  delegatedIpv6Prefix String?   @map("delegatedipv6prefix")
  class               String?   @map("class")
  
  // Relations to your app models
  // Note: routerId is NOT a standard FreeRADIUS column. It is automatically populated via:
  // - Database trigger: link_router_to_session() (see manual-migrations/000_production_triggers.sql)
  // - Trigger matches by: NAS-Identifier > Class > nasIpAddress > MAC address
  // - Applied on INSERT and UPDATE (for late-arriving nasIpAddress)
  routerId            String?
  router              Router?   @relation(fields: [routerId], references: [id])

  // Indexes for performance
  @@index([acctUniqueId], map: "radacct_active_session_idx")
  // Note: radacct_active_session_idx is optimized as a partial index (WHERE acctstoptime IS NULL)
  // See manual-migrations/004_partial_index_and_stoptime.sql for the actual partial index implementation
  @@index([nasIpAddress, acctStartTime], map: "radacct_bulk_close")
  @@index([acctStartTime, userName], map: "radacct_start_user_idx")
  @@index([acctStopTime], map: "radacct_stoptime_idx") // Index for querying completed sessions
  @@index([class], map: "radacct_calss_idx")
  @@index([routerId]) // Index for router-based queries
  @@map("radacct")
}

// FreeRADIUS user check attributes - lowercase for PostgreSQL compatibility
model RadCheck {
  id        Int    @id @default(autoincrement())
  userName  String @map("username") @default("")
  attribute String @map("attribute") @default("")
  op        String @default("==") @db.VarChar(2)
  value     String @map("value") @default("")

  @@unique([userName, attribute], map: "radcheck_unique")
  @@index([userName, attribute], map: "radcheck_username")
  @@map("radcheck")
}

// FreeRADIUS group check attributes - lowercase for PostgreSQL compatibility
model RadGroupCheck {
  id        Int    @id @default(autoincrement())
  groupName String @map("groupname") @default("")
  attribute String @map("attribute") @default("")
  op        String @default("==") @db.VarChar(2)
  value     String @map("value") @default("")

  @@unique([groupName, attribute], map: "radgroupcheck_unique")
  @@index([groupName, attribute], map: "radgroupcheck_groupname")
  @@map("radgroupcheck")
}

// FreeRADIUS group reply attributes - lowercase for PostgreSQL compatibility
model RadGroupReply {
  id        Int    @id @default(autoincrement())
  groupName String @map("groupname") @default("")
  attribute String @map("attribute") @default("")
  op        String @default("=") @db.VarChar(2)
  value     String @map("value") @default("")

  @@unique([groupName, attribute], map: "radgroupreply_unique")
  @@index([groupName, attribute], map: "radgroupreply_groupname")
  @@map("radgroupreply")
}

// FreeRADIUS user reply attributes - lowercase for PostgreSQL compatibility
model RadReply {
  id        Int    @id @default(autoincrement())
  userName  String @map("username") @default("")
  attribute String @map("attribute") @default("")
  op        String @default("=") @db.VarChar(2)
  value     String @map("value") @default("")

  @@unique([userName, attribute], map: "radreply_unique")
  @@index([userName, attribute], map: "radreply_username")
  @@map("radreply")
}

// FreeRADIUS user to group mapping - lowercase for PostgreSQL compatibility
model RadUserGroup {
  id        Int    @id @default(autoincrement())
  userName  String @map("username") @default("")
  groupName String @map("groupname") @default("")
  priority  Int    @default(0)

  @@unique([userName, groupName], map: "radusergroup_unique")
  @@index([userName], map: "radusergroup_username")
  @@map("radusergroup")
}

// FreeRADIUS post-authentication logging - lowercase for PostgreSQL compatibility
model RadPostAuth {
  id               BigInt   @id @default(autoincrement())
  username         String
  pass             String?
  reply            String?
  calledStationId  String?  @map("calledstationid")
  callingStationId String?  @map("callingstationid")
  authDate         DateTime @default(now()) @map("authdate")
  class            String?  @map("class")

  @@index([username], map: "radpostauth_username_idx")
  @@index([class], map: "radpostauth_class_idx")
  @@map("radpostauth")
}

// FreeRADIUS NAS (Network Access Server) clients - lowercase for PostgreSQL compatibility
model Nas {
  id          Int     @id @default(autoincrement())
  nasName     String  @unique @map("nasname")
  shortName   String  @map("shortname")
  type        String  @default("other")
  ports       Int?
  secret      String
  server      String?
  community   String?
  description String?

  @@index([nasName], map: "nas_nasname")
  @@map("nas")
}

// FreeRADIUS NAS reload tracking - lowercase for PostgreSQL compatibility
model NasReload {
  nasIpAddress String   @id @map("nasipaddress")
  reloadTime   DateTime @map("reloadtime")

  @@map("nasreload")
}

// FreeRADIUS user quota tracking - for cross-router quota management
model RadQuota {
  id          Int      @id @default(autoincrement())
  username    String   @map("username")
  quotaType   String   @default("monthly") @map("quota_type")
  maxOctets   BigInt   @map("max_octets")
  usedOctets  BigInt   @default(0) @map("used_octets")
  periodStart DateTime @map("period_start")
  periodEnd   DateTime @map("period_end")
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")

  @@unique([username, quotaType, periodStart])
  @@index([username], map: "radquota_username_idx")
  @@index([periodEnd], map: "radquota_period_idx")
  @@map("radquota")
}

enum Role {
  ADMIN
  HOST
}

enum RouterStatus {
  ONLINE
  OFFLINE
  ERROR
}

enum InvoiceStatus {
  PENDING
  PAID
  OVERDUE
  CANCELLED
}

// End User - WiFi users (separate from admin/host users)
model EndUser {
  id            String     @id @default(cuid())
  username      String     @unique // RADIUS username (must be unique)
  password      String     // Hashed password for RADIUS (stored in radcheck)
  email         String?    // Optional email for notifications
  phone         String?    // Optional phone number
  fullName      String?    @map("full_name")
  status        EndUserStatus @default(ACTIVE)
  notes         String?    // Admin notes
  createdById   String?    // ID of admin/host who created this user
  createdAt     DateTime   @default(now()) @map("created_at")
  updatedAt     DateTime   @updatedAt @map("updated_at")
  
  // Relations
  userPlans     UserPlan[] // Current and historical plan assignments
  
  @@index([username])
  @@index([status])
  @@index([createdById])
  @@map("end_users")
}

// Service Plans - Define data quotas, bandwidth, time limits
model Plan {
  id                String     @id @default(cuid())
  name              String     // e.g., "Basic 10GB", "Premium Unlimited"
  description       String?    // Plan description
  price             Decimal    @default(0) @db.Decimal(10, 2) // Monthly price
  currency          String     @default("USD")
  
  // Data Quota (in bytes)
  dataQuota         BigInt?    @map("data_quota") // Total data allowed (null = unlimited)
  quotaType         QuotaType  @default(MONTHLY) @map("quota_type") // MONTHLY, DAILY, WEEKLY, ONE_TIME
  
  // Bandwidth Limits (in bytes per second)
  maxUploadSpeed    BigInt?    @map("max_upload_speed") // Upload bandwidth limit (null = unlimited)
  maxDownloadSpeed  BigInt?    @map("max_download_speed") // Download bandwidth limit (null = unlimited)
  
  // Time Limits
  sessionTimeout    Int?       @map("session_timeout") // Max session duration in seconds (null = unlimited)
  idleTimeout       Int?       @map("idle_timeout") // Idle timeout in seconds (null = unlimited)
  maxSessions       Int?       @default(1) @map("max_sessions") // Max concurrent sessions (null = unlimited)
  
  // Validity Period
  validityDays      Int?       @map("validity_days") // Plan validity in days (null = unlimited)
  
  // Status
  status            PlanStatus @default(ACTIVE)
  isDefault         Boolean    @default(false) @map("is_default") // Default plan for new users
  
  // Metadata
  createdById       String?    @map("created_by_id")
  createdAt         DateTime   @default(now()) @map("created_at")
  updatedAt         DateTime   @updatedAt @map("updated_at")
  
  // Relations
  userPlans         UserPlan[]
  renewalPlans      UserPlan[] @relation("PlanRenewal")
  
  @@index([status])
  @@index([isDefault])
  @@map("plans")
}

// User Plan Assignment - Links users to plans with expiry
model UserPlan {
  id                String     @id @default(cuid())
  userId            String     @map("user_id")
  user              EndUser    @relation(fields: [userId], references: [id], onDelete: Cascade)
  planId            String     @map("plan_id")
  status            UserPlanStatus @default(ACTIVE)
  
  // Assignment period
  assignedAt        DateTime   @default(now()) @map("assigned_at")
  activatedAt       DateTime?  @map("activated_at") // When plan becomes active
  expiresAt         DateTime?  @map("expires_at") // Plan expiry (null = never expires)
  
  // Usage tracking
  dataUsed          BigInt     @default(0) @map("data_used")
  dataQuota         BigInt?    @map("data_quota") // Quota for this assignment (can override plan default)
  
  // Auto-renewal
  autoRenew         Boolean    @default(false) @map("auto_renew")
  renewalPlanId     String?    @map("renewal_plan_id") // Plan to renew to (null = same plan)
  
  // Metadata
  assignedById      String?    @map("assigned_by_id") // Admin who assigned this plan
  notes             String?    // Assignment notes
  createdAt         DateTime   @default(now()) @map("created_at")
  updatedAt         DateTime   @updatedAt @map("updated_at")
  
  // Relations
  plan              Plan       @relation(fields: [planId], references: [id], onDelete: Restrict)
  renewalPlan       Plan?      @relation("PlanRenewal", fields: [renewalPlanId], references: [id])
  
  @@index([userId, status])
  @@index([planId])
  @@index([expiresAt])
  @@index([status, expiresAt])
  @@map("user_plans")
}

enum EndUserStatus {
  ACTIVE
  INACTIVE
  SUSPENDED
  EXPIRED
}

enum PlanStatus {
  ACTIVE
  INACTIVE
  ARCHIVED
}

enum UserPlanStatus {
  PENDING    // Assigned but not yet active
  ACTIVE     // Currently active
  EXPIRED    // Expired
  CANCELLED  // Manually cancelled
}

enum QuotaType {
  MONTHLY    // Resets monthly
  DAILY     // Resets daily
  WEEKLY    // Resets weekly
  ONE_TIME  // One-time quota (doesn't reset)
}

// Disconnect Queue - For quota enforcement
// Users who exceed quota are queued here for CoA disconnect
// Note: Partial unique index on (username) WHERE processed = FALSE is created in SQL migration
model DisconnectQueue {
  id         Int      @id @default(autoincrement())
  username   String
  reason     String   @default("QUOTA_EXCEEDED")
  processed  Boolean  @default(false)
  createdAt  DateTime @default(now()) @map("created_at")
  processedAt DateTime? @map("processed_at")

  @@index([username], map: "idx_disconnect_queue_unprocessed")
  @@index([createdAt], map: "idx_disconnect_queue_created")
  @@map("disconnect_queue")
}

